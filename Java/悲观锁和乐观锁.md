##悲观锁和乐观锁##

####1、概念####
* 锁。<br/>我们知道，最常用的处理多用户并发访问的方法是加锁。当一个用户锁住数据库中的某个对象时，其他用户就不能再访问该对象。加锁对并发访问的影响体现在锁的粒度上。比如，放在一个表上的锁限制对整个表的并发访问；放在数据页上的锁限制了对整个数据页的访问；放在行上的锁只限制对该行的并发访问。可见行锁粒度最小，并发访问最好，页锁粒度最大，表锁介于2者之间。
* 锁有两种：悲观锁和乐观锁。
	* 悲观锁假定**其他用户企图访问或者改变你正在访问、更改的对象的概率是很高的**，因此在悲观锁的环境中，在你开始改变此对象之前就将该对象锁住，并且直到你提交了所作的更改之后才释放锁。悲观的缺陷是不论是页锁还是行锁，加锁的时间可能会很长，这样可能会长时间的限制其他用户的访问，也就是说悲观锁的并发访问性不好。<br/>**应用实例：**如果我们需要建立一个在线的百科 —— 使用Couchbase Server的应用程序：用户可以修改和添加文章。假设一下Alice正在使用应用程序对“bicycles”上的一篇文章进行编辑（修改一些信息），但是在保存前Alice忽然想起一些其它的事情并离开了电脑；就在这个时候Joe也注意到了“bicycles”文章上的相同错误并且准备纠正。<br/>如果应用程序中使用的是乐观锁，Joe就可以编辑文章并保存修改。当Alice返回并准备保存修改的时候，那么不管是Alice或者是应用程序都希望知道文档的最新状态 —— 在Alice修改文档的行动得到允许前。乐观锁的出发点在于该数据很少会因为并发修改而产生冲突，所以并发修改显得更重要一点。
	* 与悲观锁相反，乐观锁则认为**其他用户企图改变你正在更改的对象的概率是很小的**，因此乐观锁直到你准备提交所作的更改时才将对象锁住，当你读取以及改变该对象时并不加锁。可见乐观锁加锁的时间要比悲观锁短，乐观锁可以用较大的锁粒度获得较好的并发访问性能。但是如果第二个用户恰好在第一个用户提交更改之前读取了该对象，那么当他完成了自己的更改进行提交时，数据库就会发现该对象已经变化了，这样，第二个用户不得不重新读取该对象并作出更改。这说明在乐观锁环境中，会增加并发用户读取对象的次数。 <br/>**应用实例**：这里不防设想一下你的业务流程需要互斥存取一个或多个文档（又或是一个graph中的文档）。参照上面的例子：当Alice正在编辑文档的时，她不想其他的用户对相同的文档进行编辑。如果这时Joe再去做同样的事情，那么他必须等待直到Alice释放锁。通过使用悲观锁，应用程序可以实现对文档的单独占有。当用户完成文档的访问后，可以手动或者设置超时来释放锁。


####2、实践####

#####2.1 数据库缓存####
当对数据库相同记录产生比较多的读，这个时候并发的瓶颈就会发生在数据库上面，依赖数据库保证数据的一致性，压力测试最终结果就是连接池用光，TPS无法再升上去，而且数据库的水平扩展比起应用的水平扩展难度系数大的多(这里要考虑数据同步和一致性)。此时利用使用**乐观锁**的缓存能够满足当前的需求：<br/>
分析此时的场景：
读远多于写，而且数据一致性通过数据库来保证，大部分系统也是这样，这个时候用一个`HashMap`作为缓存，读的时候从`HashMap`中取就OK，一旦缓存没有命中，就会锁住该对象，执行查询数据库做相应的更新操作。数据放入缓存之前加上一个 `version_id`， 其实就是一个时间戳，客户端拿着这个 `version_id`去服务端去查， 如果没有命中，就锁住对象，执行更新操作，放入缓存，耽误也就一位用户的时间，牺牲小我，完成大我。

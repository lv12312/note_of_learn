##Python内存管理和垃圾回收

###1. 内存管理

* 变量无需提前声明
* 无需声明变量类型
* 无需程序员主动管理内存
* 变量名可以被“回收二次利用”
* del 语句使其允许显式的“回收内存”

####1.1 变量声明和内存分配
Python中，没有显式的变量声明，变量都是在第一次赋值的时候声明的。对象的类型和内存分配都是在运行期确定的。Python中，内存的管理都是交给解释器来做的，只需关注业务实现即可。


###2. 垃圾回收
一般的垃圾回收算法有：引用计数、标记-清除和节点复制算法。

####2.1 引用计数算法
基本手段是为每个单元计算指向它的引用的数量。每个单元都有一个额外的域，存放引用计数值(Reference count)。

算法：
自由单元的引用计数值是0，当一个新单元从池中被分配的时候，它的引用计数值被设置为1；而每次删除某个指向它的指针时，它的计数值减1。如果单元的计数值减为0, 引用计数不变式告诉我们不再存在指向该单元的指针。

####2.2 增加引用计数和减少计数
引用计数增加

* 引用创建 `x = 3.14`

* 增加别名 `y = x`

* 传递给函数(创建新的局部引用) `foobar(x)`

* 成为容器对象的一部分 `myList = [123, x, 'xyz']`

引用计数减小

	#如：
	foo = 'xyz' #'xyz'引用计数加1
	bar = foo	#'xyz'引用计数加1
	foo = 123	#'xyz'引用计数减1


* 局部变量脱离作用域
* 对象的别名显式的销毁 `del y`
* 别名引用另外一个对象
* 显式从容器对象中移除 `myList.remove(x)`
* 容器自己被回收了 `del myList`

####2.3 Python垃圾回收

解释器对引用计数持续的追踪，但是还是要依靠垃圾回收器来对内存进行回收。垃圾回收器是一段独立的代码，用来发现引用计数为0的对象，而且也负责检查引用计数大于0的对象——出现循环引用。

Python垃圾回收器结合了引用计数和定时调用循环引用垃圾回收器。当一个对象的应用计数为0，解释器暂停将其回收。除了引用计数，垃圾回收器同样会观察是否大量对象已分配(不是通过引用计数的减小来回收内存)，在这种情形下，解释器会暂停来尝试清理没有被引用的循环引用。


##1、MySQL架构和历史

MySQL在互联网行业很具竞争力，MySQL同其他数据库有很大的不同，得益于其优秀的架构，让用户不得不选择MySQL。

###1.1 MySQL逻辑架构

![MySQL架构图](http://photocdn.sohu.com/20130419/Img373311101.jpg)

+ 第一层：管理认证，线程重用，连接限制，内存管理
+ 第二层：查询解析，分析，优化，缓存，还有一些内置功能等等。
+ 第三层：存储引擎，负责存储和获取所有数据。
+ 第四层：文件系统等。

####1.1.1 连接管理和安全

每一个客户端连接都要在服务端创建一个独立线程。查询操作都在一个线程中完成。服务端能够缓存线程，不是每次都需要创建新线程和销毁新线程。MySQL 5.5之后提供支持线程池的插件的API。

当客户端连接到MySQL服务器，服务器需要对其进行权限验证。权限验证主要基于host,username和password。可以在SSL上使用X.509认证。

####1.1.2 优化和执行
MySQL将查询解析为内部结构，然后执行优化。优化器并不真的知道表使用哪个存储引擎，但是存储引擎会影响服务器对查询的优化。

在执行查询之前，会使用查询缓存，只是缓存SELECT语句和他们的结果。

###1.2 并发控制
任何时刻可能就有多个查询需要改变数据，此时的并发问题就产生了。MySQL在两个维度上控制并发：服务器维度和存储引擎维度。

* 读/写锁。读锁在资源上都是共享的，或者称之为非阻塞的：多个客户端可以同时读取相同的资源而不产生干扰。写锁是排他的，同时锁住读锁和其他写锁。
* 锁粒度。为了提高锁的效率，锁的时候只锁需要改变的那些数据。锁是需要消耗资源的，每一个锁操作都是要消耗计算的，如果系统花了太多时间去处理锁的的问题，系统性能难免会下降。MySQL不同的引擎提供了不同的锁策略。主要有两种锁策略：
	* 表锁。最基本的MySQL锁策略，比较暴力的一种锁，锁住整个表。
	* 行锁。这种锁提供高并发能力，行锁在InnoDB引擎和XtraDB引擎都可用。行锁是存储引擎实现的，而不是数据库服务器。

###1.3 事务
事务就是将一组SQL语句作为一个原子操作。事务带来的负面效果是需要更多的CPU计算能力，内存和磁盘存储。事务是存储引擎所需要负责的。有些时候可以不使用带有事务的存储引擎来提升性能，可能有些时候可以使用锁表来作为事务的替代，这个取决于用户。

####1.3.1 隔离级别
SQL标准定义了四种隔离级别。低的隔离级别允许更高的并发和低的性能损耗。

* READ UNCOMMITTED: 这种隔离级别，事务可以看到未提交事务的结果。这种级别通常比较少用，会造成**脏读**。
* READ COMMITTED: 大部分数据库的默认隔离级别(不是MySQL)。事务只可以看到提交事务后的结果。这种也叫**做不可重复读**。意味着执行相同的语句可能看到不同的结果。
* REPEATABLE READ: 解决了READ UNCOMMITTED的问题，它保证任何一行在一个事务里面事务的前后都是一致的读结果，但是这样会造成“幻读”。简单的讲，“幻读”发生在你查询一些行，但是之后某事务往里面插入了一些行，然后你重新查询一些行，就会发现一些“莫名出来的”行。InnoDB和XtraDB使用多版本并发控制器来解决幻读问题。**可重复读是MySQL默认的隔离级别**
* SERIALIZABLE: 最高的隔离级别， 串行化的，简单的讲，该级别就是读也要加上锁，效率会非常低下，很少会使用该级别。

####1.3.2 死锁
死锁问题就是多个事务同时竞争相同的资源导致的循环依赖。为了消除该问题，在InnoDB存储引擎中，将会发现循环依赖的问题，并且抛出错误。死锁通常会被标记为慢查询。InnoDB处理死锁问题的方式是回滚包含最少排他行的事务(估测一下最容易恢复回滚的那个事务)。

死锁在没有回滚部分或全部事务时是无法消除的。在存在事务的的系统中，应用需要设计来处理回滚的问题。很多系统知识简单的重试事务。

####1.3.3 事务日志

事务日志会让事务更加有效。除了每次变更产生的时候更新表，存储引擎都会改变内存中的值，并持久的记录事务日志。通常是一个比较快的操作，增加日志只是个连续的写操作。然后再写磁盘上的数据。尽管大部分的存储引擎都会使用某种机制(提前些机制)来防止写磁盘两次。如果在事务日志已经写入磁盘了之后，系统发生了宕机，重启系统之后，存储引擎会恢复这些变化。

####1.3.4 MySQL中的事务
MySQL提供了两种支持事务的存储引擎：InnoDB和NDB Cluster。有第三方的存储支持事务：XtraDB和PBXT。

* AUTOCOMMIT: 默认的开启的，关于数据变更的语句会立即开启一个事务，结束之后会立即提交。
* 事务中的混合引擎：如果事务中有不支持事务的引擎存储的表(如：MyISAM和InnoDB), MySQL服务器不会报错，可能就抛出一个警告。
* 显式和隐式的锁： InnoDB使用两段锁协议。在事务的过程中可以随时获取锁，但是直到COMMIT或ROLLBACK的时候才会释放。所有的锁都是隐式的。但是, InnoDB支持显式的锁，但是并不是很常见。

###1.4 多版本的并发控制
大部分的MySQL存储引擎不会使用简单的**行锁**机制，而是使用行锁和MVCC(Multiversion Concurrency Control多版本的并发控制)混合版本。不只是MySQL使用了，Oracle和PostgreSQL也用了。

MVCC在一段时间内对数据保持一个快照。意味着事务可以看到数据的一致化视图，不管他运行了多长时间，同样意味着**相同的表同一时刻不同的事务可以看到不同的数据**。

每一个支持事务的存储引擎实现MVCC都是不同的，可能包含着**悲观**和**乐观**的并发控制。
InnoDB实现MVCC是依靠每行存储一次额外的数据，当该行创建或者失效(删除)的时候记录隐藏值。当每次事件发生时，都会记录下版本号。每次事务的开始都会增加该版本号。每个事务都保存着自己当前的系统的版本。每次查询都会检查每行的事务版本号。


###1.5 MySQL的存储引擎

常见的有MyISAM和InnoDB。其他的查看文档。

还有一起其他的存储引擎：XtraDB, PBXT在MariaDB中提供。
TokuDB, RethinkDB，等。